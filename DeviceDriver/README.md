# 리눅스 커널과 디바이스 드라이버

## 목차

1. [리눅스 커널](#리눅스-커널)
2. [디바이스 드라이버](#디바이스-드라이버)

## 리눅스 커널

### ⦁ 리눅스 커널의 기능
커널은 시스템에 존재하는 지원을 효율적으로 관리히는 지원 관리자로, 그 기능을 간릭하게 살펴보면 디음과 같다.

#### - 프로세서 관리

    일반 PC 는 하나의 CPU, 즉 프로세서 하나를 시용한다. 그러나 고속 처리가 필요한 서버 시스템의 경우에는 처리 속도를 향상시키기 위해 여러 프로세서를 병렬로 연결하여 사용한다. 시스템에서 동작히는 프로세스도 키널에서는 관리해야 할 지원이고， 운영체제의 처리 요구에 맞춰 통직할 수 있도록 각 프로세스에 필요한 프로세서를 효율적으로 할당하고 수행하도록관리한다.

#### - 프로세스 관리
    리녹스 운영체제에서는 시스템이 동작 이후에 최소한 하나 이싱의 프로세스가 동작한다. 이 프로세스는 다른 말로 태스크라고도 하며， 주어진 일을 수행하는 기본 단위다. 커널은 프로세스 스케줄러를 이용하여 여러 프로세스가 동작할 수 있도록 각 프로세스를 생성하고 제거하며， 외부 환경과 프로세스를 연결하고 관리한다.

#### - 메모리 관리
    시스템에서의 메모리는 프로세서와 마찬가지로 가장 핵심적이고， 중요하게 관리해야 하는 자원이다. 메모리를 관리히는 정책은 시스템 성능을 결정하는 중요한 요소로， 각각의 프로세스가 독립적인 공간에서 수행할 수 있도록 가싱 주소 공간을 제공한다. 이 가상 메모리 관리를 바탕으로 보조 기억 장치와 연동하여 물리적인 한계를 극복할수 있는 기능을 제공한다.

#### - 파일 시스템 관리
    리녹스 커널은 유닉스 시스사에서 시용히는 파일 시스템을 근간으로 설계되었다. 그래서 리녹스 커널에서 동직히는 응용 프로그램은 시스템에 동작하는 모든 자원을 파일처럼 다룰 수 있도록 통일된 인터페이스를 제공한다. 또한 리녹스 커널은 가성 파일 시스템(VFS)을 이용하여 현존하는 대부분의 파일 시스템 형식을 지원한다.

#### - 디바이스 제어
    운영체제에서 동작히는 응용 프로그램의 결과는 하드웨어와 반드시 연결되어야 사용자가 인지할 수 있다. 메모리와 프로세서를 제외한다면 그 외의 동작은 반드시 하드웨어적인 처리를 수반한다. 하드웨어에 관련된 처리는 디바이 스 드라이버에서 담당하며， 커널이 반드시 구현해야 하는 것 중 하나다. 리녹스 커널은 파일 시스템의 구조에 디바이스 드라이버를 연동히여 구현하며， 표준회된 형식으로 하드디스크부터 키보드 이더넷과 같은 모든 주변장치를 관리한다.

#### - 네트워크 관리
    현대의 시스템은 반드시 네 트워크 처리를 수반한다 현존하는 운영체제 중에는 네트워크 처리를 수행하지 않는 운영체제도 있겠지만 리녹스 커널은 네 트워크를 필요로 하는 시스템에서 주로 개발되었기 매문에 가장 우수한 네트워크 관리 시스템을 갖추고 있다. 리녹스 커널은 네트워크 스택을 이용하여 응용 프로그램과 네트워크 디바이스 드라이버를 연결하며， 매우 효율적인 네트워크 처리를 구현하고 있다. 또한 리녹스 커널에서 동작히는 네트워크 시스템은 암호회와 보안특성이 연계된 매우 견고한 시스템을 구성한다.

### ⦁ 리눅스 커널의 특징

리눅스 커널은 운영체제에서 가장 중요한 부분으로 프로세서와 시스템 메모리에 상주하면서 디바이스나 메모리 같은 하드웨어 자원을 관리하고, 프로세스의 스케줄을 관리하여 다중 프로세스를 구현하고, 시스템에 연결된 입출력을 처리하는 운영체제의 핵심 역할을 수행한다.

리눅스의 큰 특징은 사용자가 스르로 커널을 만들고 수정할 수 있어서 리눅스 커널은 소스 형태로 배포되고 있으며, 실행 파일로 배포되는 경우는 배포판 패키지에 포함된다. 

리눅스 커널의 대표적인 특징으로는

#### - 모놀리식 커널
    리눅스 커널은 대부분의 유닉스 커널과 같은 모놀리식(monolithic)이다. 모놀리식이기 때문에 논리적으로 구분되는 여러가지 구성 요소들이 상호간에 복잡하게 연결되어 동작한다.

#### - 비선점형(커널 2.4)과 선점형(커널 2.6)
    2.6이전 버전은 비선점형 커널로 프로세스의 동작상태가 사용자 모드에서 커널 모드로 진입하면 외부에서 해당 프로세스를 중지시키지 못한다.
    선점형은 2.6부터 지원되며 프로세스가 커널 모드로 종작하더라도 스케줄링 정책이나 다른 외부적인 접근을 통해 프로세스를 강제로 중지시킬 수 있다.

#### - 가상 메모리 시스팀(VM)
    리눅스 커널은 다양한 플랫폼에서 동작하는 운영체제로 i386에서 동작되던 메모리 관리 시스템을 표준화하여 다양한 MMU 디바에스에 적용할 수 있도록 구성되었으며, 보조 기억 장치를 이용하여 물리적인 메모리의 한계를 극복할 수 있는 가상 메모리 관리 방식을 구현한다.

#### - No MMU 지원
    리눅스 커널은 i386 계열에서 발전한 시스템이기 때문에 MMU를 이용한 메모리 관리를 수행하는데 임베디드 시스템에서 자주 사용되는 프로세서의 경우에는 이런 MMU 디바이스가 없는 경우가 있어 커널 2.6에서는 이런 프로세서를 지원하기 위한 프로젝트가 포함되어 MMU가 없는 시스템도 지원하게 되었다.

#### - 가상 파일 시스템(VFS)
    리눅스 커널의 가장 큰 특징 중 하나이다. 유닉스의 파일 시스템을 수용하면서도 다른 많은 파일 시스템을 처리할 수 있도로 가상 파일 시스템을 구현한다. 리눅스에서는 ext2부터 저널링 파일 시스템인 jfs까지 다양한 파일 시스템을 사용할 수 있고, 윈도우에서 동작하는 NTFS 파일 시스템과 DOS용 파일 시스템도 처리할 수 있다.

#### - 모듈을 이용한 커널 확장
    윈도우와 같은 대부분의 최신 커널은 운영체제가 동작하는 중에도 커널 코드를 추가하거나 삭제할 수 있다. 특히 hotplug를 지원하는 하드웨어의 경우에는 이런 기능이 필수적이다. 리눅스 커널은 이러한 기능을 모듈이라는 방식으로 구현한다.

#### - 커널 스레드
    2.6 부터는 NPTL(Native POSIX Threading Library)과 NGPT(Next Generation POSIX Threading Package)를 지원한다.

#### - 멀티스레드 지원
    리눅스 커널은 기존의 프로세스 관리 기법을 다순화하여 멀티스레드를 지원한다.

#### - 강력한 네트워크 지원
    리눅스 커널은 BSD 네트워크 처리 방식을 계승했기 때문에 네트워크 처리의 안정성 및 효율이 매우 높다. 현존하는 대부분의 네트워크 프로토콜을 지원한다.

#### - GPL 라이선스
    리눅스 커널의 가장 큰 특징 중 하나는 GPL 라이선스다. 그래서 누구나 소스를 참조할 수 있고, 수정하여 재배포할 수 있다.

### ⦁ 커널 소스의 구조
리눅스 커널 소스 트리는 커널이 수행하는 기능을 중심으로 디렉토리가 구성되어 있고, 그 구조가 매우 방대하다. 모든 내용을 소개할 수는 없으므로 디바이스 드라이버를 학습하기 위한 디렉토리 중심으로 나열함.

+ 커널 디렉토리 소개

|디렉토리|설명
|:---:|:---:|
| Documentation/ | 커널에 관련된 여러 참고 문서 |
| arch/ | 플랫폼에 의존적인 코드 |
| cypto/ (2.6) | 암호 처리 |
| drivers/ | 하드웨어를 제어하는 디바이스 드라이버 |
| fs/ | 파일 시스템 구현 |
| include/ | 커널 소스 헤더 파일 |
| init/ | 커널 초기화 코드 |
| ipc/ | 시스템 V 프로세스간 통신 |
| kernel/ | 프로세스, 타이밍, 프로그램 실행, 시그널, 모듈 등 커널 핵심 코드 |
| lib/ | 커널 내부적으로 사용하는 범용 함수 라이브러리 |
| mm/ | 메모리 관리 |
| net/ | 네트워크 프로토콜 스택 |
| scripts/ | 커널 이미지를 만들기 위해서 사용되는 셀 스크립트 및 프로그램 |
| security/ (2.6) | 보안처리 |
| usr/ (2.6) | initramfs 시스템 구축 예제 |

#### - Documentation/
    디바이스 드라이버 작성자라면 필수적으로 참고해야 하는 내용이 들어가 있는 디렉토리로, 커널 내에 구현되어 있는 소스를 이용할 때 시스템에 따라 발생할 수 있는 주의 사항부터 디바이스 드라이버의 표준 구현 방법에 이르기까지 매우 다양한 내용이 들어 있다.

#### - arch/
    리눅스 커널이 다양한 CPU 아키텍처(x86, ARM, MIPS, PowerPC 등)에서 동작할 수 있도록, 각 아키텍처에 특화된 코드를 포함. 부팅 코드, 메모리관리 유닛(MMU) 설정, 인터럽트 처리 등 아키텍처 종속적인 부분이 여기에 있음.

#### - include/
    커널 내부에서 사용되는 모든 헤더 파일이 위치. linux/
    서브디렉토리에는 일반적인 커널 헤더가, uapi/ 서브디렉토리에는 사용자 공간프로그램과 커널 간의 인터페이스를 정의하는 헤더 파일이 있다.

## 디바이스 드라이버

### ⦁ 커널에 자원 처리를 요청하는 방법
디바이스 드라이버(device driver)는 시스템이 지원하는 하드웨어를 응용 프로그램에서 사용 할 수 있도록 커널에서 제공하는 라이브러리다. 대부분의 운영체제가 그러하듯 하드웨어는 커널에서 관리하는 시스템 자원으로 본다. 응용 프로그램이 하드웨어를 제어하려면 커널에 자원 사용을 요청하고, 커널은 이런 요청에 따라 시스템을 관리한다. 응용 프로그램이 커널에게 자원 처리를 요청하는 방법은 크게 두가지로 첫번째는 시스템 호출 방식이며, 두번째는 파일 입출력 형식을 이용하여 디바이스 드라이버를 사용하는 방식이다.

#### - 시스템 호출 방식
    시스템 호출 방식이란 시스템 제어에 필요한 호출 규칙을 정해 놓고, 소프트웨어 인터럽트 서비스를 이용하여 응용 프로그램에서 요청하는 처리를 커널이 수행하는 방식이다. 커널은 처리해야 하는 기능들을 구별하기 위해 각 기능별로 번호를 할당하고, 이 번호에 제어 루틴을 커널 내부에 정의한다. 응용 프로그램은 원하는 기능 번호를 레지스터에 저장한 후 소프트웨어 인터럽트 서비스를 호출함으로써 커널에 제어를 넘긴다. 인터럽트에 의해 호출된 후 커널 내의 서비스 루틴은 모두 처리된 후 커널은 응용 프로램에 다시 제어권을 넘긴다.

#### - 파일 형식의 디바이스 드라이버
    유닉스는 하드웨어를 다루기 위해 기존의 시스템 호출 방식과 병행해서 파일 입출력 함수로 하드웨어를 제어하는 개념을 도입한다. 이 방식은 일반 파일을 제어하듯이 하드웨어를 표현하는 디바이스 파일에 응용 프로그램의 입출력을 시도하면 커널 내의 해당 디바이스 파일에 연결된 디바이스 드라이버의 서비스 루틴이 호출되어 디바이스에 대한 처리가 이루어지고 모든 처리가 끝나면 커널이 제어 흐름을 다시 응용 프로그램으로 넘기는 구조이다.
    리눅스 커널은 이런 방식을 이어받아 구현했지만 디바이스 파일을 이용한 하드웨어 제어 방식은 응용 프로그램을 개발하는 개발자가 디바이스에 접근하는 방식을 표준화했고, 디바이스 드라이버를 제작하는 개발자도 일관된 인터페이스 맞춰 서비스 루틴을 작성할 수 있게 되었다.

### ⦁ 모듈과 디바이스 파일

#### - 모듈
    모듈 방식은 리눅스에 포함된 디바이스 드라이버를 개발할 때 개발 시간을 단축시킬 뿐만 아니라 필요없는 기능은 커널에 포함시키지 않음으로써 커널 자원을 효율적으로 다루게 한다. PCI, USB, PCMCIA 에 연계된 디바이스의 PNP 기능을 지원하려면 모듈 방식이 꼭 필ㅇ요하다. 예를 들면 PCMCIA 같은 경우에는 디바이스의 착탈이 가능한데, 모듈을 이용하면 커널이 디바이스의 추가와 삭제에 대응할 수 있다.

#### - 디바이스 파일
    디바이스 파일(Device File)은 리눅스(유닉스 계열 운영체제)에서 하드웨어를 말한다.

    장치나 가상 장치에 접근하기 위한 특별한 종류의 파일을 말합니
    리눅스에서 동작하는 응용 프로그램에는 하드웨어를 다루기 위한 특별한 함수나 방법이 없다. 물론 시스템 콜이라는 형식이 있지만, 이는 커널과 응용 프로그램을 서로 연결시키는 인터페이스지 실질적으로 하드웨어를 제어하는 통로는 아니다. 리눅스는 시스템에 있는 모든 자원을 파일 형식으로 표현하는데 램, 프로세스나 태스크도 파일로 표현한다. 키보드나 보조 기억 장치인 하드디스크도 파일로 표현한다. /dev/ 디렉토리 하부에 있는 파일들은 조금 특이한데 리눅스에서는 /dev/ 디렉토리에 있는 파일들을 보통 디바이스 파일이라고 한다. 이 디바이스 파일 하나 하나는 실질적인 하드웨어를 표현하는데 시스템에서 연결된 마우스 입력 디바이스는 /dev/mouse라는 디바이스 파일로 표현한다. 화면에 입력이나 출력을 처리하는 것 역시 /dev/console이라는 디바이스 파일로 표현된다. /dev/ 디렉토리 밑에는 수많은 디바이스 파일이 있는데, 그 크기는 그리 크지 않으며 파일 삭제문으로 제거할 수도 있고, 시스템에 없는 수많은 디바이스 파일도 있다.

    이런 디바이스 파일은 일종의 정보 파일로 일반 파일의 목적이 데이터를 저장하는 데 있다면 디바이스 파일은 시스템 또는 하드웨어 정보를 제공하는 데 목적이 있다. 이 디바이스 파일에 저장되는 정보는 세 가지로, 디바이스 타입 정보와 주 번호(Major), 부 번호(Minor)다. 디바이스 타입 정보는 디바이스가 문자인지 블록인지를 구별한다. 주 번는 응용 프로그램과 디바이스 드라이버를 연결하는 고리다. 응용 프로그램은 open() 함수로 디바이스 파일을 열면 커널은 해당 디바이스 파일에서 주 번호를 얻고, 이 주번호애 의해 처리되는 디바이스 드라이버를 찾는다. 이렇게 응용 프로그램과 디바이스 드라이버를 주 번호로 연결되면 부 번호가 처리하고자 하는 실질적인 디바이스를 나타낸다. 물론 부 번호는 디바이스 드라이버에 따라 의미가 달라지기 때문에 꼭 이렇게 동작하지는 않지만 대부분의 디바이스 드라이버에서의 부 번호는 실질적인 디바이스를 나타내는 경우가 많다.

    반면에 디바이스 파일이 없는 디바이스 드라이버로는 네트워크 디바이스 드라이버가 있다.

### ⦁ 디바이스 드라이버의 종류
리눅스에서 사용되는 디바이스 드라이버는 크게 **문자 구조**, **블록 구조**, **네트워크 구조**로 나뉜다. 이 구조들은 리눅스 커널에서 사용하는 방식과 밀접하게 연관되어 있다. 이 기본적인 구조에서 다시 각각의 하드웨어에 맞게 디바이스 드라이버의 구조가 다양하게 변형된다.
- 문자 : 임의의 길이를 갖는 문자열을 다루는 디바이스 드라이버로 응용 프로그램에서 직접적으로 호출되는, 버퍼없는 디바이스 드라이버
- 블록 : 일정 크기의 버퍼를 통해 데이터를 처리하는 디바이스로, 커널 내부의 파일 시스템에서 관리하고 내부적인 버퍼가 있는 디바이스 드라이버
- 네트워크 : 네트워크층과 연결된 디바이스 드라이버

#### - 문자 디바이스 드라이버
    문자 디바이스 드라이버는 일반 파일과 가장 유사한 방식으로 처리할 수 있는 디바이스 드라이버이다. 응용 프로그램은 open(), close(), read(), write()와 같은 파일 처리용 함수를 이용하여 디바이스 파일을 일반 파일처럼 다뤄서 하드웨어를 처리할 수 있다. 구조가 간단하고 응용 프로그램의 호출과 1:1로 대응되기 때문에 대부분의 하드웨어는 문자 디바이스 드라이버로 구현할 수 있다.

#### - 블록 디바이스 드라이버
    블록 디바이스 드라이버는 특별한 경우(파티션 분할)가 아니면 응용 프로그램에서 직접적으로 사용하지 않는 디바이스 드라이버다. 대신 파일 시스템을 지원하는 구조이므로 응용 프로그램은 파일 시스템을 통해 접근하고 블록 디바이스의 효율적인 처리를 위해 커널은 내부에 버퍼를 이용하여 처리한다.

#### - 네트워크 디바이스 드라이버
    문자 디바이스 드라이버와 블록 디바이스 드라이버는 일반 파일 형식으로 접근할 수 있지만, 네트워크 디바이스 드라이버는 응용 프로그램에서 직접적으로 처리할 수 없다. 단지 커널 내부에 있는 네트워크 프로토콜 스택과 연동하도록 설계되어 있다. 디바이스 파일이 없고 네트워크 디바이스 드라이버의 구조는 네트워크 디바이스 드라이버만을 위한 것이다.

### ⦁ 통합형 디바이스 드라이버(커널 2.6)
리녹스는 기본적인 형식 위에 다양한 형태의 하드웨어를 쉽게 다룰 수 있도록 디바이스 드라이버의 구성을 좀더 체계화시켰고 커널 2.6 에서는 통합형 디바이스 드라이버로 다룬다. 통합형 디바이스 드라이버는 다음에 나열한 항목과 같은 형태로 디바이스 드라이버와 관련된 개념을 정리한다. 한 가지 오해하지 말아야 할 것은 통합형 디바이스 드라이버는 커널 내부의 관리 체계에서 처리 방식을 통합했다는 의미지 디바이스드리아버의 구성 형태가통합되었다
는 의미는 아니라는 점이다.

- device : 실제 존재하는 하드웨어를 의미.
- drvier : 디바이스를 제어하는 소프트웨어를 의미.
- bus : 하드웨어가 연결된 버스를 의미.
- class : 하드웨어의 종류를 의미.
- interface : 논리적인 인터페이를 의미.

#### - sysfs
    통합된 디바이스 드라이버에 관련되어 커널 2.6 에서 새로 등장한 파일 시스템이 sysfs다. 이 파일 시스템은 셀에서 디바이스 드라이버의 구성에 관련된 정보를 쉽게 볼 수 있는데，커널에서 디바이스 드라이버를 트리 구조로 관리하고 있음을 간접적으로 보여준다. 보통 다음과 같이 마운트 한다.

```bash
[root@]# mount -t sysfs sysfs /sys
```

#### - device
    디바이스란 커널에서 동작하는 하드웨어 개체를 의미한다. 하나의 디바이스 드라이버는 실제로 다루는 디바이스가 하나인 경우와 하나 이상인 경우가 있다. 이런 경우는 디바이스와 디바이스 드라이버를 별도로 관리해야 하는데 드라이버의 실제 제어 대상이 되는 것을 디바이스라고 한다. 이 디바이스는 struct device에서 정의하여 등록되며, 이 정보는 커널에서 관리한다.

#### - driver
    드라이버란 디비이스를 다루는 실질적인 소프트웨어를 의미한다 드라이버는 하나이상의 디바이스를 디룰 수 있고， 하나의 디바이스는 거꾸로 여러 드라이버에 의해 동작할 수도 있다. 이런 드라이버를 다루기 위해 커널에서는 struct device_driver 를 이용하여 드라이버 특성을 정의하고 등록한다. 이 정보는 커널에서 관리한다.

#### - bus
    모든 디바이스는 버스라는 전기적인 신호 라인에 의해 프로세서에 연결된다. 프로세서에 직접적으로 연결되는 버스도 있고 간접적으로 연결되는 버스도 있다. 하나의 시스템에는 여러 가지 버스가 복합적으로 동작하고, 디바이스는 하나의 버스에 소속된다. 드라이버는 각 디바이스에 접근하기 위해 버스를 제어하는 디바이스를 다루며， 버스를 통해 디바이스에 접근할 수 있다. 대표적인 버스 형식으로 PCI, IDE, USB, PCMClA, SCSI, I2C 와 같은 것들이 있다. 버스 역시 커널로 다루어야 하기 때문에 struct bus_type 이라는 구조체를 시용하여 버스를 정의하고 등록한다. 이 정보는 커널에서 관리한다.

#### - class
    디바이스와 드라이버와 별도로， 처리하는 행위에 따라서 하드웨어를 분류할 수 있는데， 이를 클래스라고 한다 예를 들어 USB 키보드는 입력 디바이스의 일종이다. 하지만 USB 디바이스기도하다. 이렇게 하나의 디바이 스드라이버는 사용목적에 따라 달리 관리해야 한다. 이렇게 디바이스를 종류별로 관리하기 위해 struct device_class 라는 구조체를 사용하여 특성을 정의하고 등록한다. 이 정보는 커널에서 관리한다.

#### - interface
    각 디바이스를 종류별로 구별하기는 하지만 어떻게 입출력을 처리하는가에 따라 다르게 구별해야 한다. 예를 들어， 사용자의 입력을 받는 대표적인 디바이스로 마우스가 있다. 이 마우스는 응용 프로그램에서 사용된다. 이와 유사한 디바이스 중에서 터치 스크린이 있다. 터치 스크린 역시 응용 프로그램에서는 마우스로 취급되어 처리된다. 하지만 구현 방식도 다르고， 실제로 입력 방식도 다르다 이렇게 입출력 처리가 달라지는 것을 관리하기 위해 struct device_interface 라는 구조체를 사용하여 특성을 정의하고 등록한다. 이 정보는 커널에서 관리한다.

