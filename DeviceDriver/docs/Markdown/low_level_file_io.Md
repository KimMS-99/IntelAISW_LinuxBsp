# 저수준 파일 입출력 함수

저수준 파일 입출력 함수는 리눅스 커널에서 제공하는 파일 관련 시스템 콜을 라이브러리 함수로 만든 것으로, 스트림 파일 입출력 함수와 달리 중간에 버퍼가 없다. 그래서 쓰기 함수를 이용해 파일에 데이터를 쓰면 데이터가 파일에 즉시 기록되고 이와 같이 수행 내용이 파일에 바로 적용되므로 다바이스 파일을 대상으로 저수준 파일 입출력 함수를 이용하면 디바이스 파일에 연관된 디바이스 드라이버 함수가 바로 동작한다.

+ 디바이스 파일에 쓰인 함수

| 저수준 파일 입출력 함수 | 기능 |
|:---:|:---:|
|[oepn()](#파일-열고-닫기--open-close-함수) | 파일이나 장치를 연다.
| [close()](#파일-열고-닫기--open-close-함수) | 열린 파일을 닫는다.
| [read()](#파일-읽고-쓰기--read-write-함수) | 파일에서 데이터를 읽어온다.
| [write()](#파일-읽고-쓰기--read-write-함수) | 파일에 데이터를 쓴다.
| [lseek()](#파일-포인터-처리--lseek-함수) | 파일의 쓰기나 읽기 위치를 변경한다.
| [ioctl()](#디바이스-제어--ioctl-함수) | read(), wrtie()로 다루지 않는 특수한 제어를 한다.
| [fsync()](#동기-처리--fsync-함수) | 파일에 쓴 데이터와 실제 하드웨어의 동기를 맞춘다.

디바이스 드라이버 작성자는 함수를 적용할 때 전달되는 매개변수와 함수 실행 결과로 반횐되는 값의 의미를 정확하게 알고 있어야 한다. 특히 반환값이 에러와 관련된 경우는 매우 중요하다. 디바이스 드라이버는 결국 파일 관련 함수의 전달값을 처리하고, 반환값을 제공하도록 만들어야 하기 때문이다.

## ⦁ 파일 열고 닫기 : open(), close() 함수
저수준 파일 함수를 이용하려면 **open()** 함수에서 반환된 파일 디스크립터값을 저장하는 정수형 변수가 필요하다. 이 정수형 변수에 저장된 값은 커널에서 반환한 내부 파일 처리 인덱스라 보면 되는데, 이 변수값을 처리할 파일을 구별하고 보통 다음과 같이 선언한다.
```c
int fd = -1;
```
이 변수는 파일을 다루는 함수를 사용할 때 꼭 필요하기 때문에 파일을 닫기 전까지는 유지되어야 한다. 초기값으로 -1을 대입하는 이유는 **open()** 함수를 통해 파일이 정상적으로 열리면 값이 0 이상이 되므로, 파일이 열리지 않은 상태에서 저수준 파일 입출력 함수를 사용할 경우에 발생하는 에러를 방지하기 위해서다.

파일을 열기 위해서는 파일명과 파일을 열기 위한 속성이 필요하다. 파일명은 NULL 문자로 끝나는 문자열이어야 하는데, 보통 "dev/" 디렉토리에 있는 디바이스 파일을 사용한다.
```c
fd = open("/dev/mem", O_RDWR | O_NONBLOCK);
if(fd < 0)
{
    // 에러 처리
}

close(fd);
```

디바이스 파일은 일반 파일과 달리 저수준 파일 함수에서 파일 생성을 처리하는 옵션이나 함수를 사용하지 못하므로 **O_CREATE**와 관련된 옵션을 사용하지 못한다. **open()** 함수는 디바이스 파일을 정상적으로 열면 0 이상의 값을 반환하고, 에러가 발생하면 0보다 작은 값을 반환한다. 에러는 주로 다음과 경우에 발생하고, 어떤 에러인지는 반환값이나 error 변수를 참조하면 알 수 있다.
- 디바이스 파일이 없다.
- 디바이스 파일에 연결된 디아이스 드라이버가 없다.
- 디바이스 드라이버에서 에러 조건이 발생한다.

디바이스 파일은 일반 파일과 달리 쓰기나 읽기 전용인 경우가 드물기 때문에 대부분 **O_RDWR**옵션을 준다. 대신 디바이스가 쓰거나 읽는 행위가 종료되는 시점까지 저수준 입출력 함수가 대기해야 하는 블로킹(blocking)에 신경써야 한다. 블로킹 처리 시간은 하드웨어 구조에 따라 대기 시간이 달라지므로 무한히 대기하는 경우가 발생할 수 있다. 그래서 순차적인 처리가 중요한 경우에는 읽기나 쓰기 조건이 완료되지 않더라도 저수준 파일 입출력 함수가 즉시 종료되도록 **O_NONBLOCK**이나 **O_NDELAY** 옵션을 사용한다. 그리고 이 두 옵션을 사용한 경우에는 비블록 모드, 즉 수행 조건이 완료되지 않더라도 함수가 정상적으로 실행되므로 처리에 신경써야 한다.

**open()**함수로 열린 디바이스 파일은 **close()** 함수로 닫아야 한다. 그런데 **close()** 함수를 사용해 디바이스 파일을 닫는 경우에는 대부분 반환값을 확인하지 않는다. 에러를 반환하더라도 달리 대처할 방법이 없기 때문이다. 

## ⦁ 파일 읽고 쓰기 : read(), write() 함수
**open()** 함수로 열린 디바이스 파일을 통해 하드웨어를 제어할 때, read(), write() 함수를 가장 자주 사용한다. 이 함수의 사용법은 일반 파일과 같고 파일 디스크립터를 이용해 적용할 파일을 지정하고, 처리할 데이터의 주소와 처리 데이터 수치를 준다.
```c
ret_num = read(fd, buff, 10);
ret_num = write(fd, buff, 10);
```
단 디바이스 파일을 다룰 때 일반 파일과 다른 점은 두 가지다.
- 블록 모드에 대한 처리 여부
- 요구된 데이터의 수와 처리된 데이터 수의 차이

이 두 가지를 다르게 처리해야 하지만, 처리 방식은 거의 유사하다. 블록 모드일 경우에는 에러가 발생하지 않는 이상 요구된 데이터의 수는 처리된 데이터의 수는 처리된 데이터의 수는 처리된 데이터의 수와 대부분 일치한다. 하지만 실제 프로그램을 작성할 때는 일치하지 않는 경우를 처리해야 한다.
```c
ret_num = read(fd, buff, 10);
if(ret_num < 0)
{
     // 에러 처리
}
if(ret_num != 10)
{
    // 요구된 것과 다를 때 처리
}
```
보통 요구된 것과 다를 때는 디바이스 드라이버가 어떻게 작성되어 있는가와 프로그램의 진행 구조에 따라 다르게 처리된다. 필요하다면 읽거나 쓰고자 하는 조건을 만족할 때까지 다시 호출되는 구조로 만들어도 되지만, 대부분 정상적으로 읽거나 쓰여질 것으로 예상하고 처리한다.

**read()** 또는 **write()** 함수를 이용해 디바이스 파일의 데이터를 읽거나 쓸 때, 일반 파일과 가장 다른 점은 데이터가 보존되지 않는다는 점이다. **write()** 함수를 이용해 데이터를 썼더라도 데이터는 하드웨어에 저장되는 것으로 끝난다. 디바이스 드라이버가 하드웨어에 쓴 데이터를 기억하고 이를 다시 **read()** 함수로 읽을 수 있다면 보존되겠지만, 이런 종류의 디바이스 드라이버는 ram과 같은 기억 소작을 다루는 경우 이외에는 매우 드물다. 그래서 파일 끝을 감지하는 것도 별로 의미가 없다.

## ⦁ 파일 포인터 처리 : lseek() 함수
디바이스 파일에서 파일 포인터의 의미는 일반 파일과 다르다. 일반 파일에서는 파일에 쓰거나 읽을 데이터의 위치가 되며, **read()** 또는 **write()** 함수를 이용해 갱신된다. 강제로 읽고 쓰는 위치를 변경하려면 **lseek()** 함수를 사용한다. 그러나 디바이스 파일에서는 파일 포인터의 위치에 대한 정의가 디바이스 드라이버마다 다르기 때문에 대부분 디바이스 파일에는 사용되지 않으며, 메모리나 하드디스크와 같은 기억 장치와 관련된 경우에만 처리된다. 그리고 디바이스 드라이버에 따라 파일 포인터를 사용할 필요가 있다면 다음과 같은 형식으로 처리한다.
```c
off_t ret_pos;

ret_pos = lseek(fd, 1234, SEEK_CUR);
```
위치 변위값은 바이트 단위고, 대부분 **SEEK_CUR**을 사용해 현재 위치를 기준으로 파일의 위치를 지정한다. 일반 파일의 경우, 파일 포인터의 위치 변경이 처리 시간에 영향을 주어 상대 위치를 지정해서 사용하는 것과 달리, 디바이스 파일에는 파일의 끝이라는 개념이 없는 경우가 많고, 상대 위치라는 개념도 없는 경우가 많으므로 가급적 **SEEK_CUR**을 사용하는 편이 좋다.

## ⦁ 디바이스 제어 : ioctl() 함수
연결된 하드웨어에 따라 디바이스 파일을 다르게 제어해야 한다. 그런데 이 모든 제어를 **read()** **write()**함수만으로 처리하기가 곤란하므로 일반 파일에서는 사용하지 않는 **ioctl()**함수를 사용한다. 이 함수는 일반 파일에서 적용할 수 없으며, 디바이스 파일에만 해당되는 것이므로 [(정리하고 링크랑 이름 걸어라)]()에서 자세히 설명한다.

## ⦁ 동기 처리 : fsync() 함수
일반 파일은 데이터를 쓰는 순간 파일에 저장되는데 디바이스 파일에 저장된 데이터는 연결된 디바이스 드라이버의 구현 방식에 따라 실제 하드웨어에 저장될 수도 있고, 디바이스 드라이버 내부의 버퍼에 저장될 수도 있다. 하드웨어를 제어하기 위해 디바이스 파일을 다룰 경우, 디바이스 드라이버 내부 버퍼에 있는 데이터를 모두 적용해야 할 때 **fsync()** 함수를 사용한다.
```c
int ret;

ret = fsync(fd);
```
이 함수를 사용할 때의 주의점은 디바이스 파일에 따라 실행 시간이 길어지거나 함수가 종료되지 않을 수도 있다는 것이다. 그래서 알람과 같은 처리를 이용해서 현재 시간을 지정하는 등의 처리가 필요한 경우가 있고 지연 시간이 길어지면 디바이스 드라비어를 개선해야 할 필요가 있지만, 대부분 그리 긴 시간을 소모하지는 ㅇ낳는다.

이 외에도 디바이스 파일과 관련된 **select()**, **poll()**, **mmap()**, **ummap()** 함수가 있다.