# 리눅스 보드 지원 패키지 (Linux Board Support Package) 이해하기

## 1. BSP란 무엇인가?

BSP(Board Support Package)는 특정 하드웨어 보드(예: 라즈베리파이, i.MX 8 등)에서 리눅스(Linux) 운영체제가 완벽하게 작동할 수 있도록 필요한 모든 소프트웨어 구성 요소를 묶어놓은 패키지입니다.

- **핵심 역할:** 하드웨어의 복잡성을 추상화하여, 응용 프로그램 개발자가 하드웨어의 세부 동작을 몰라도 제품을 쉽게 개발할 수 있도록 기반 환경을 제공합니다.
- **비유:** 컴퓨터에 Windows를 설치한 후, 메인보드, 그래픽카드 등의 드라이버를 모두 설치해야 정상적으로 동작하는 것과 같습니다. BSP는 이 드라이버들을 포함하여 운영체제 핵심까지 하드웨어에 맞게 최적화한 '필수 소프트웨어 묶음'입니다.

---

## 2. BSP의 핵심 구성 요소

BSP는 크게 5가지 핵심 요소로 구성됩니다.

### 가. 부트로더 (Bootloader)
- **역할:** 하드웨어 전원이 켜졌을 때 가장 먼저 실행되는 프로그램입니다.
- **주요 임무:**
    1. 최소한의 하드웨어(CPU, 메모리 등)를 초기화합니다.
    2. 저장장치(eMMC, SD카드 등)에서 리눅스 커널 이미지를 읽어 RAM으로 복사합니다.
    3. 커널을 실행시키고 제어권을 넘겨줍니다.
- **예시:** U-Boot, GRUB

### 나. 리눅스 커널 (Linux Kernel)
- **역할:** 운영체제의 심장으로, 시스템의 모든 자원(CPU, 메모리, 장치)을 관리하고 제어합니다.
- **BSP에서의 특징:** 특정 보드의 CPU 아키텍처에 맞게 컴파일되고, 해당 보드의 하드웨어 구성을 인식하도록 수정되어 있습니다.

### 다. 디바이스 드라이버 (Device Drivers)
- **역할:** 커널과 하드웨어 장치 사이의 통역사 역할을 합니다. 커널의 명령을 실제 하드웨어 제어 신호로 변환합니다.
- **커널과의 관계:** 드라이버는 커널의 일부로서, 커널이 제공하는 규칙(API)에 따라 동작합니다. 드라이버 없이는 커널이 하드웨어를 제어할 수 없습니다.
- **커널에 올리는 방식:**
    1. **정적 빌드 (Statically Built-in):** 커널을 컴파일할 때 드라이버를 아예 커널 이미지에 포함시킵니다. 부팅에 필수적인 핵심 장치(저장장치 컨트롤러 등)에 사용됩니다. **부트로더는 이 드라이버가 포함된 커널을 통째로 메모리에 올리는 중요한 역할을 합니다.**
    2. **동적 모듈 (Loadable Kernel Module):** 드라이버를 별도의 파일(`.ko`)로 만들어, 시스템 실행 중에 필요에 따라 커널에 올리거나(`insmod`, `modprobe`) 내릴 수(`rmmod`) 있습니다. USB, 사운드 카드 등 대부분의 장치에 사용됩니다.

### 라. 루트 파일 시스템 (Root File System, RFS)
- **역할:** 리눅스가 부팅된 후 필요한 모든 파일과 디렉토리 구조를 담고 있는 최상위 디렉토리(`/`)입니다.
- **포함 내용:**
    - `/bin`, `/sbin`: `ls`, `ifconfig` 같은 기본 명령어
    - `/etc`: 시스템 설정 파일
    - `/lib`: 프로그램 실행에 필요한 공유 라이브러리
    - `/dev`: 장치를 나타내는 특수 파일
- **역할:** 커널 부팅이 완료된 후, 시스템 운영에 필요한 환경을 제공합니다.

### 마. 툴체인 (Toolchain)
- **역할:** BSP를 구성하는 모든 소프트웨어(부트로더, 커널, 응용 프로그램 등)를 개발하고 컴파일하는 데 필요한 도구 모음입니다.
- **주요 구성:** 컴파일러(GCC), 링커(ld), C 라이브러리(glibc) 등.

---

## 3. BSP 개발 도구: Yocto Project

- **Yocto는 BSP 자체가 아닙니다.** Yocto는 위에서 설명한 BSP의 구성 요소들을 자동으로 빌드하여 **맞춤형 BSP를 생성해주는 강력한 프레임워크이자 도구**입니다.
- **비유:** Yocto가 '주방+레시피 북'이라면, BSP는 Yocto를 이용해 만든 '완성된 요리'입니다.
- **장점:** Yocto를 사용하면 개발자는 필요한 패키지를 추가하거나 제외하고, 설정을 변경하여 특정 제품에 최적화된 자신만의 리눅스 시스템(BSP)을 효율적으로 구축할 수 있습니다.

---

## 4. 시스템 콜: 응용 프로그램과 BSP의 연결고리

BSP가 아무리 잘 만들어져 있어도, 일반 응용 프로그램이 이를 사용하려면 특별한 통로가 필요합니다. 그것이 바로 **시스템 콜(System Call)**입니다.

- **개념:** 응용 프로그램(User Space)이 하드웨어 제어와 같이 스스로 할 수 없는 일을 운영체제(Kernel Space)에 대신 요청하는 공식적인 방법입니다.
- **동작 원리:**
    1. **요청:** 유저 프로그램이 `open()`, `write()` 같은 함수를 호출합니다.
    2. **모드 전환:** 이 함수는 시스템 콜을 발생시켜 CPU를 '유저 모드'에서 '커널 모드'로 전환합니다.
    3. **작업 수행:** 커널은 요청을 받아, BSP에 포함된 디바이스 드라이버를 통해 실제 하드웨어를 제어합니다.
    4. **결과 반환:** 작업 완료 후, 결과를 유저 프로그램에 반환하고 다시 '유저 모드'로 돌아옵니다.

> **결론적으로, 시스템 콜은 BSP를 통해 구현된 하드웨어 제어 기능을 일반 응용 프로그램들이 안전하게 사용할 수 있도록 연결해주는 핵심 통로입니다.**

---

## 5. BSP 전체 실행 흐름: 빌드부터 부팅까지

### 단계 1: 빌드 (Build Time - 개발자 PC)

모든 것은 Yocto Project를 통해 BSP를 구성하고 빌드하는 것에서 시작됩니다.

1.  **설계 및 구성:** 개발자는 Yocto 레시피와 설정 파일을 통해 만들고 싶은 시스템을 정의합니다.
    - 어떤 부트로더, 커널 버전을 사용할 것인가?
    - 어떤 디바이스 드라이버를 **정적(built-in)**으로 커널에 포함할 것인가?
    - 어떤 디바이스 드라이버를 **동적 모듈(`.ko`)**로 만들 것인가?
    - 루트 파일 시스템에는 어떤 프로그램(예: 웹서버, 파이썬)과 라이브러리를 포함할 것인가?

2.  **빌드 실행:** 개발자가 `bitbake <이미지_이름>` 명령을 실행합니다.

3.  **Yocto 자동화 작업:**
    - **툴체인 생성:** 빌드에 필요한 컴파일러 등을 먼저 만듭니다.
    - **소스 코드 다운로드:** 정의된 모든 소프트웨어(부트로더, 커널, 각종 프로그램)의 소스 코드를 가져옵니다.
    - **컴파일 및 생성:**
        - **부트로더**를 컴파일합니다.
        - **커널**을 컴파일합니다. 이때 정적으로 빌드하기로 한 드라이버는 커널 이미지 안에 포함됩니다.
        - **루트 파일 시스템**을 만듭니다. 동적 모듈 드라이버(`.ko` 파일)와 각종 응용 프로그램, 라이브러리들이 이 안에 배치됩니다.
    - **최종 이미지 생성:** 부트로더, 커널, 루트 파일 시스템을 합쳐 SD카드나 eMMC에 바로 쓸 수 있는 하나의 완전한 시스템 이미지 파일(예: `.wic`, `.sdcard`)을 만듭니다.

### 단계 2: 실행 (Run Time - 실제 하드웨어 보드)

빌드된 이미지를 보드에 설치하고 전원을 켜면 다음과 같은 순서로 시스템이 동작합니다.

1.  **전원 ON → 부트로더 실행**
    - 보드의 ROM 코드가 저장장치의 특정 위치에서 **부트로더**를 찾아 실행합니다.

2.  **부트로더 → 커널 로딩 및 실행**
    - 부트로더가 최소한의 하드웨어(RAM 등)를 초기화합니다.
    - 저장장치에서 **커널 이미지**를 찾아 RAM으로 복사합니다.
    - 커널로 제어권을 넘기고 부트로더의 역할은 끝납니다.

3.  **커널 부팅 및 정적 드라이버 초기화**
    - 커널이 실행을 시작하며 CPU, 메모리 관리 등 자신의 핵심 기능을 초기화합니다.
    - 이 과정에서, 커널 이미지 안에 **정적으로 포함된 드라이버들**을 깨워 초기화합니다.
    - **(중요)** 예를 들어, 저장장치(eMMC) 드라이버가 정적으로 포함되어 있다면, 이 드라이버가 먼저 초기화되어야 다음 단계에서 루트 파일 시스템을 읽을 수 있습니다. 이 시점에는 아직 루트 파일 시스템이 필요 없습니다.

4.  **루트 파일 시스템 마운트**
    - 커널은 이제 준비된 저장장치 드라이버를 이용해 저장장치 안에 있는 **루트 파일 시스템(RFS)**을 찾아 마운트합니다.
    - 이 시점부터 `/bin`, `/etc` 등 파일 시스템의 모든 파일에 접근이 가능해집니다.

5.  **시스템 초기화 및 동적 드라이버 로드**
    - 커널은 RFS에 있는 `init` 프로세스(보통 systemd)를 실행하여 시스템의 나머지 부분을 초기화합니다.
    - `init` 프로세스는 설정된 스크립트에 따라 RFS 안에 있던 **동적 드라이버 모듈(`.ko` 파일)들**을 `modprobe` 명령 등으로 커널에 로드합니다.

6.  **응용 프로그램 실행 및 시스템 콜 사용**
    - 모든 준비가 끝나면, RFS에 있는 응용 프로그램들이 실행됩니다.
    - 이 프로그램들은 하드웨어 기능이 필요할 때 **시스템 콜**을 호출합니다.
    - 커널은 이 시스템 콜을 받아, 이미 로드된 **정적 또는 동적 드라이버**에게 작업을 지시하여 최종적으로 하드웨어를 제어합니다.